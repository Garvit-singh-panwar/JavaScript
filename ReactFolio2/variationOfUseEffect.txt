ðŸ“ The Complete useEffect Cheat Sheet
Variation 1: Run on Every Render
------------

Syntax: No dependency array.


Behavior: Runs when the component mounts and after every single update (state or props change).


Use Case: Rare. Usually for global logging or manual DOM updates that must sync with every change.

JavaScript
useEffect(() => {
    console.log("I run every time the UI renders!");
});


Variation 2: Run Only Once (Mount Only)
--------------

Syntax: Empty dependency array [].

Behavior: Runs once when the component is first put on the screen. It never runs again for that component instance.

Use Case: Fetching API data, starting a timer, or initializing a library.

JavaScript
useEffect(() => {
    console.log("I only run once, right at the start.");
}, []); 


Variation 3: Run on Change (Dependency Based)
-----------

Syntax: Variables inside the array [text, name].

Behavior: Runs on the first render plus every time any value inside the brackets changes.

Use Case: Triggering a search when a user types in a search box.

JavaScript
useEffect(() => {
    console.log("I run when 'text' or 'name' changes!");
}, [text, name]); 


Variation 4: The Cleanup (Mount/Unmount Logic)
===================

Syntax: Includes a return function.

Behavior: 1. On the first render, the main code runs.

2. On subsequent renders, the return (cleanup) runs first with the old values, then the main code runs with new values.

3. When the component dies (unmounts), the return runs one last time.

Use Case: Removing event listeners, stopping intervals, or canceling API requests.

JavaScript
useEffect(() => {
    console.log("Step 2: Logic added (Subscribed)");

    // The Cleanup Function
    return () => {
        console.log("Step 1: Old Logic removed (Unsubscribed)");
    }
}, [text]);

ðŸ’¡ Summary Table for Quick Reference
Variation	Array Syntax	Execution Timing
Every Render	None	Every render cycle.
On Mount	[]	Once, when component loads.
On Update	[prop/state]	Mount + when the specific value changes.
With Cleanup	[prop/state] + return	Before the next effect runs & on unmount.


ALL About Variation 4 :-
-----------------------
-----------------------


ðŸ“ React useEffect Lifecycle Notes
1. The Mounting Phase (The First Time)
When your component first appears on the screen (mounts):

The Main Body of the useEffect runs.


The Cleanup Function (the return part) does NOT run on the very first render.

2. The Re-render Phase (The "Update")
When the dependency (e.g., text) changes:

Cleanup First: React runs the code inside the return block using the old values.


Main Body Second: React runs the main code inside the useEffect using the new values.

3. The Unmounting Phase (The "Goodbye")
When the component is removed from the screen:

Only the Cleanup Function runs to "tidy up" (e.g., removing event listeners).


ðŸ’» The Corrected Code & Logic
Your code is actually written correctly! Here is how it behaves behind the scenes:
JavaScript
useEffect(() => {
  // --- Part A: The Setup ---
  console.log("Listener added");

  // --- Part B: The Cleanup ---
  return () => {
    console.log("Listener removed");
  };

}, [text]); 
Execution Flow:

First Render: Prints Listener added.


Type "A" in input: - First, it prints Listener removed (cleaning up the previous state).


Then, it prints Listener added (setting up for the new state).


Type "B" in input: - Prints Listener removed.


Prints Listener added.


ðŸ’¡ Why do we do this?
As you mentioned, if you add an event listener (like a scroll listener or a socket connection) every time the text changes, you will eventually have hundreds of listeners running at the same time. This is called a Memory Leak.
The Golden Rule: Always "undo" in the return function what you "did" in the main body.

If you addEventListener â†’ removeEventListener in return.


If you setInterval â†’ clearInterval in return.


If you subscribe â†’ unsubscribe in return.

